Data: 30/03/2017

1. Quantos pipes serão criados após as linhas de código a seguir? Por quê?
	(a) 	int pid;
		int	fd[2];
		pipe(fd);
		pid = fork();

		Neste caso, é criado apenas um Pipe entre o processo pai e o processo filho


	(b) 	int pid;
		int	fd[2];
		pid = fork();
		pipe(fd);
		
		Neste caso, o Fork() é utilizado antes separando o processo em dois, criando assim  2 pipes, um entre processo pai e filho
		e outro entre processos filhos

2. Apresente mais cinco sinais importantes do ambiente Unix, além do SIGSEGV, SIGUSR1, SIGUSR2, SIGALRM e SIGINT. Quais são suas características e utilidades?
		
		- SIGQUIT: Sinal emitido aos processos do terminal quando as teclas (QUIT ou CTRL+D) do teclado são acionadas (Teclas de abadono)
		- SIGILL: Sinal emitido quando uma instrução ilegal é detectada
		- SIGIOT: Sinal emitido após problema com Hardware
		- SIGBUS: Sinal emitido em caso de erro no barramento
		- SIGSYS: Sinal emitido quando há argumento incorreto de uma chamada de sistema

3. Considere o código a seguir:

	 1. #include <signal.h>
	 2. #include <unistd.h>
	 3. #include <stdio.h>
	 4. #include <stdlib.h>
	 5.
	 6. void tratamento_alarme(int sig)
	 7. {
	 8. 	system("date");
	 9. 	alarm(1);
	10. }
	11. 
	12. int main()
	13. {
	14. 	signal(SIGALRM, tratamento_alarme);
	15. 	alarm(1);
	16. 	printf("Aperte CTRL+C para acabar:\n");
	17. 	while(1);
	18. 	return 0;
	19. }

Sabendo que a função alarm() tem como entrada a quantidade de segundos para terminar a contagem, quão precisos são os alarmes criados neste código? De onde vem a imprecisão? Este é um método confiável para desenvolver aplicações em tempo real?

	A imprecisão dessa função está no tempo que demora para realizar cada linha de código, fazendo com que o tempo de espera do Alarme não seja
de exatos 1 segundo. Logo é um método não tão confiável quando se deseja obter precisão alta.